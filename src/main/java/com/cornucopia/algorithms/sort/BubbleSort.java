package com.cornucopia.algorithms.sort;

/**
 * 一.冒泡排序.
 *
 * 1.第一，冒泡排序是原地排序算法吗？
 *   冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以它的空间复杂度为 O(1)，是一个原地排序算法。
 *
 * 2.第二，冒泡排序是稳定的排序算法吗？
 *   在冒泡排序中，只有交换才可以改变两个元素的前后顺序。为了保证冒泡排序算法的稳定性，当有相邻的两个元素大小相等的时候，我们不做交换，相同大小的数
 *   据在排序前后不会改变顺序，所以冒泡排序是稳定的排序算法。
 *
 * 3.第三，冒泡排序的时间复杂度是多少？
 *   3.1 最好情况 时间复杂度O(n)
 *   3.2 最坏情况 事件复杂度O(n*n)
 *   3.3 有序度,具有有序关系的元素对的个数
 *       2，4，3
 *       (2,4) (2,3)
 *
 *   3.4 无序度,
 *       (4,3)
 *   3.5 满序度，完全有序的数组的有序度。
 *       2,4,3
 *   3.6 满序度=有序度+无序度
 *
 * 4.比较和交换
 *           4 5 6 3 2 1
 *   初始状态               3次
 *   满有序度  6*(6-1)/2
 *   交换次数  12
 *   交换次数=满有序度-初始有序度
 *
 *
 *
 * @author cornucopia
 * @version 1.0
 * @since 2019-11-05
 */
public class BubbleSort implements ISort {


    @Override
    public void sort(int[] a, int n) {
        if (n <= 1) {
            return;
        }
        for (int i = 0; i < n; i++) {
            //避免重复计算，一旦发现元素没有进行交换位置，那么认定已经排好序
            boolean flag = false;
            for (int j = 0; j < n - i - 1; ++j) {
                if (a[j] > a[j + 1]) {
                    int tmp = a[j];
                    a[j] = a[j + 1];
                    a[j + 1] = tmp;
                    flag=true;
                }
            }
            if(!flag) break;
        }

    }
}
